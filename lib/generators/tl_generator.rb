require 'fileutils'
require_relative '../parser/tl_parser'
require_relative '../parser/source_builder'

module TlGenerator
  def self.tlobjects_exist()
    # Determines whether the TLObjects were previously generated (hence exist) or not
    return File.exist?('lib/tl/all_tlobjects.rb')
  end

  def self.generate_tlobjects(scheme_file)
      # Generates all the TLObjects from scheme.tl to tl/functions and tl/types

      # First ensure that the required parent directories exist
      FileUtils.mkdir_p('lib/tl/functions')
      FileUtils.mkdir_p('lib/tl/types')

      # Store the parsed file in a tuple for iterating it more than once
      #tlobjects = tuple(TLParser.parse_file(scheme_file)) # find where tuple defined
      tlobjects = TLParser.parse_file(scheme_file)
raise tlobjects.inspect

=begin
      for tlobject in tlobjects do
          # Determine the output directory and create it
          out_dir = os.path.join('tl',
                                 'functions' if tlobject.is_function
                                 else 'types')

          if tlobject.namespace is not None
            out_dir = os.path.join(out_dir, tlobject.namespace)

          FileUtils.mkdir_p(out_dir)

          # Also add this object to __init__.py, so we can import the whole packet at once
          init_py = os.path.join(out_dir, '__init__.py')
          with open(init_py, 'a', encoding='utf-8') as file:
              with SourceBuilder(file) as builder:
                  builder.writeln('from {} import {}'.format(
                      get_full_file_name(tlobject), get_class_name(tlobject)))

          # Create the file for this TLObject
          filename = os.path.join(out_dir, get_file_name(tlobject, add_extension=True))
          with open(filename, 'w', encoding='utf-8') as file:
              # Let's build the source code!
              with SourceBuilder(file) as builder:
                  builder.writeln('from tl.mtproto_request import MTProtoRequest')
                  builder.writeln()
                  builder.writeln()
                  builder.writeln('class {}(MTProtoRequest):'.format(get_class_name(tlobject)))

                  # Write the original .tl definition, along with a "generated automatically" message
                  builder.writeln('"""Class generated by TLObjects\' generator. '
                                  'All changes will be ERASED. Original .tl definition below.')
                  builder.writeln('{}"""'.format(repr(tlobject)))
                  builder.writeln()

                  # First sort the arguments so that those not being a flag come first
                  args = sorted([arg for arg in tlobject.args if not arg.flag_indicator],
                                key=lambda x: x.is_flag)

                  # Then convert the args to string parameters, the flags having =None
                  args = [(arg.name if not arg.is_flag
                          else '{}=None'.format(arg.name)) for arg in args
                          if not arg.flag_indicator and not arg.generic_definition]

                  # Write the __init__ function
                  if args:
                      builder.writeln('def __init__(self, {}):'.format(', '.join(args)))
                  else:
                      builder.writeln('def __init__(self):')

                  # Now update args to have the TLObject arguments, _except_
                  # those which are generated automatically: flag indicator and generic definitions.
                  # We don't need the generic definitions in Python because arguments can be any type
                  args = [arg for arg in tlobject.args
                          if not arg.flag_indicator and not arg.generic_definition]

                  if args:
                      # Write the docstring, so we know the type of the arguments
                      builder.writeln('"""')
                      for arg in args:
                          if not arg.flag_indicator:
                              builder.write(':param {}: Telegram type: «{}».'.format(arg.name, arg.type))
                              if arg.is_vector:
                                  builder.write(' Must be a list.'.format(arg.name))
                              if arg.is_generic:
                                  builder.write(' This should be another MTProtoRequest.')
                              builder.writeln()
                      builder.writeln('"""')

                  builder.writeln('super().__init__()')
                  # Functions have a result object and are confirmed by default
                  if tlobject.is_function:
                      builder.writeln('self.result = None')
                      builder.writeln('self.confirmed = True  # Confirmed by default')

                  # Set the arguments
                  if args:
                      # Leave an empty line if there are any args
                      builder.writeln()
                      for arg in args:
                          builder.writeln('self.{0} = {0}'.format(arg.name))
                  builder.end_block()

                  # Write the on_send(self, writer) function
                  builder.writeln('def on_send(self, writer):')
                  builder.writeln("writer.write_int({}, signed=False)  # {}'s constructor ID"
                                  .format(hex(tlobject.id), tlobject.name))

                  for arg in tlobject.args:
                      write_onsend_code(builder, arg, tlobject.args)
                  builder.end_block()

                  # Write the on_response(self, reader) function
                  builder.writeln('def on_response(self, reader):')
                  # Do not read constructor's ID, since that's already been read somewhere else
                  if tlobject.is_function:
                      builder.writeln('self.result = reader.tgread_object()')
                  else:
                      if tlobject.args:
                          for arg in tlobject.args:
                              write_onresponse_code(builder, arg, tlobject.args)
                      else:
                          # If there were no arguments, we still need an on_response method, and hence "pass" if empty
                          builder.writeln('pass')
                  builder.end_block()

                  # Write the __repr__(self) and __str__(self) functions
                  builder.writeln('def __repr__(self):')
                  builder.writeln("return '{}'".format(repr(tlobject)))
                  builder.end_block()

                  builder.writeln('def __str__(self):')
                  builder.writeln("return {}".format(str(tlobject)))
                  # builder.end_block()  # There is no need to end the last block
      end

      # Once all the objects have been generated, we can now group them in a single file
      filename = os.path.join('tl', 'all_tlobjects.rb')
      File.open(filename, 'w', encoding='utf-8') do |file|
          with SourceBuilder(file) as builder:
              builder.writeln('"""File generated by TLObjects\' generator. All changes will be ERASED"""')
              builder.writeln()

              # First add imports
              for tlobject in tlobjects:
                  builder.writeln('import {}'.format(get_full_file_name(tlobject)))
              builder.writeln()

              # Then create the dictionary containing constructor_id: class
              builder.writeln('tlobjects = {')
              builder.current_indent += 1

              # Fill the dictionary (0x1a2b3c4f: tl.full.type.path.Class)
              for tlobject in tlobjects:
                  builder.writeln('{}: {}.{},'
                                  .format(hex(tlobject.id), get_full_file_name(tlobject), get_class_name(tlobject)))

              builder.current_indent -= 1
              builder.writeln('}')
      end
=end
  end
end

if TlGenerator.tlobjects_exist()
  print('Detected previous TLObjects. Cleaning...')
  TlGenerator.clean_tlobjects()
end

print('Generating TLObjects...')
scheme_file_path = __dir__ + '/scheme.tl'
TlGenerator.generate_tlobjects(scheme_file_path)
print('Done.')
